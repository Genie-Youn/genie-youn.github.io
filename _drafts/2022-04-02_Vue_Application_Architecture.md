---
layout: post
title: "Vue Application Architecture (Part1)"
author: "genie-youn"
categories: journal
tags: [Vue, Front End, Architecture, DDD]
image: DSC04956.jpg
---

수백개의 페이지와 이를 구성하는 천여개의 컴포넌트로 이루어진 Vue 애플리케이션을 개발하면서 기하급수적으로 늘어나는 애플리케이션의 복잡함을 다루기 위해 나름의 설계를 찾으려 애썼다.

여러 고민끝에 몇가지 원칙과 설계에 관한 계층 구조를 정의하였고 나의 이러한 고민이 비슷한 고민을 하고 있는 프론트엔드 개발자들에게 조금이나마 도움이 되길 바라며 소개해본다.

> "당연한 소리를 길게도 적어두었네" 라고 생각할지도 모르겠다.

# 복잡함을 해결해야하는 이유

개발하고 있는 프론트엔드 애플리케이션의 복잡함에 압도당해본적이 있는가?

```
새로운 기능을 추가하거나, 기존 기능에 대한 개선을 요청받아서 관련된 코드를 열었는데 갑자기 숨이 턱 막힌다거나..

천라인이 넘어가는 `if` 로 점칠된 컴포넌트를 만났다거나..

분명 5분전에 배포한건 서버 API인데 내 애플리케이션이 동작하지 않게 되었다거나..

브라우저의 네트워크탭에 찍힌 응답값은 분명 멀쩡한데 애플리케이션 내에서 돌고 돌아 갑자기 값이 뒤바뀌었다거나..

갑자기 옆 동료가 Git Blame 을 열더니 나를 째려보고 있다거나..
```

애플리케이션의 복잡해짐으로써 생기는 가장 큰 문제는 더 이상 변경에 유연하게 대응할 수 없다는 것이다.

시장은 빠르게 변화하고 우리가 사용자에게 제공하는 서비스는 이에 발맞춰 빠르게 변화할 수 있어야 한다.

하지만 복잡해진 애플리케이션은 이러한 시장의 요구사항에 기민하게 반응할 수 없다.

기획자나 디자이너에게 "그건 좀 어렵겠는데요." 라고 얘기하거나 "이건 공수가 꽤 필요하겠는데요." 라고 이야기 하는 빈도가 잦아진다.

변화에 뒤쳐진 애플리케이션은 더 이상 사용자에게 유쾌한 경험을 주지 못하게 되고 서비스의 매력을 잃게 만들어 결국 시장에서 도태되게 만든다.

따라서, 개발자는 시장의 요구사항을 빠르게 수용할 수 있도록 애플리케이션의 **복잡함**을 관리해야만 한다.

> 만약 위와 같은 문제를 느낀적이 없다면, 굳이 이 글을 더 이상 읽을 필요가 없다. 설계는 문제를 해결하기 위한 의사결정이고 반드시 트레이드오프가 따르게 된다. 현재 구조로도 충분히 새로운 기능을 추가하기 쉽고 기존 기능을 변경하는게 수월하다면 그게 내가 만들고자 하는 애플리케이션에 최적화된 설계일것이다.

# 내가 만든 애플리케이션이 복잡한 이유

복잡함이 왜 문제인지는 충분히 얘기를 한 것 같으니, 그럼 내가 만든 애플리케이션이 **왜** 복잡해졌는지를 이야기 해볼까 한다.

애플리케이션이 복잡해지는덴 여러 이유가 있겠으나 나의 경우는 결국 **책임**이 문제였다.

Vue 애플리케이션 본질적인 역할은 상태에 따른 UI를 렌더링하고 UI와 사용자의 인터렉션을 처리하며 이 인터렉션에 따라 상태를 업데이트하고 업데이트된 상태에 맞게 UI를 다시 렌더링하는 것이다.

요즘 서비스들은 사용자들에게 편리한 UI/UX를 제공하기 위해 끊임없이 고민하고 새로운 접근방식을 시도하기 때문에 위와 같은 메커니즘은 그 자체만으로도 많은 복잡성을 가지게 되고 변경주기도 짧다.

문제는 그 자체만으로도 복잡한 이 메커니즘에 API를 통해 서버와 메세지를 주고 받고, 클라이언트에서 처리해야 하는 서비스정책이나 업무규칙까지 끌어안아 괴물이 되어버린 것이다.

우선 "UI와 관련된 책임들과 그렇지 않은 것들을 명확하게 분리해내야겠다." 라는 생각이 들었다.

---- 기본적으로 Layered Architecture 를 채용해 계층별로 큰 틀의 책임을 부여하였다. UI, Application, Domain & API Client, Infra 네개의 계층으로 구성된다.

> 왜 Layered Architecture 인가? 라고 묻는다면 사실 큰 이유는 없다. 필자가 그나마 가장 잘 이해하고 있는 애플리케이션 아키텍처이고 아마 동료들도 비슷할것이라 생각했다. 서비스를 혼자 개발하는 것이 아닌 개발조직의 규모가 어느정도 꽤 있는편이었기 때문에 모두가 잘 알고있는 아키텍처를 채택하는편이 좋다고 판단했다. ... 길라잡이 역할을 해야한다는 내용도 넣으면 좋겠다..

가장 하위 계층인 Infra 계층부터 살펴보도록 하자.

## Infra

애플리케이션이 동작하기 위한 기반 기술을 제공하는 계층이다. 클라이언트 애플리케이션에서 서버와 메세지를 주고 받는 책임을 갖는 모듈이나 로컬스토리지, 세션스토리지와 같은 저장소에 접근하여 데이터를 영속화하는 책임을 갖는 모듈들이 이 계층에 속한다.

왜 이러한 모듈들을 별도 계층으로 격리해야 하는걸까?

### 기반 기술의 구체적인 구현체는 "반드시" 변경해야 하는 순간이 온다.
이 계층의 모듈들은 그 특성상 애플리케이션 전반에서 광범위하게 의존하게 된다. 예를들어 서버와 메세지를 주고 받는 기술의 구현체로 `axios` 를 사용중이라고 하자. 이 `axios` 라는 구체적인 구현체를 별다른 격리 없이 다음과 같이 사용하였다.

--- 예제다시
AwesomeComponent.vue
```vue
<template>
  <button @click="action">액션!</button>
</template>
<script>
import axios from "axios";

export default {
  methods: {
    action() {
      axios.post("/my-awesome-action");
    },
  }
}
</script>
```

그러던 어느 날 세상에 없던 멋진 HTTP Client 라이브러리가 짜잔하고 등장하였다.

합리적인 알고리즘으로 요청과 응답을 멋지게 캐시해주고 그 결과 요청의 수도 획기적으로 줄일 수 있고 응답속도 또한 빨라진다고 한다.

프로젝트에 당장 적용하고 싶어졌다. `axios` 를 걷어내고 이 멋진 라이브러리로 대체하리라.

헌데 위와 같이 `axios` 에 직접 메세지를 전달하는 컴포넌트가 수백개쯤 된다면?

아마 저 멋진 라이브러리는 아직 스타도 몇개 없고 안정성도 검증되지 않았다며 신포도라고 여겼을 것이다.

필자가 개발하고 있는 서비스는 날짜/시간대 관련된 처리를 `moment.js` 에 위임하고 있었다.

하지만 굴지의 `moment.js` 는 더 이상 신규 개발없이 유지보수만 하는 레거시 프로젝트로 전환하였고 이에 따라 새로운 라이브러리로 교체해야만 했다.

만약 이 `moment.js` 에 직접 의존하게 설계했다면 모든 사용처를 찾아 새로운 라이브러리에 맞게 변경해주었어야 했을 것이다.

정리하면 기반 기술의 구체적인 구현체, 특히 구현을 제어할 수 없는 외부 라이브러리라면 추상화된 인터페이스를 정의하고 상위계층에선 이 인터페이스를 의존하게 해라.

우선 해당 기반 기술을 추상화하여 인터페이스를 정의한다.

/date-time/DateTime.ts
```typescript
export default interface DateTime {
  isSameDay(dateLeft: Date, dateRight: Date): boolean;
  addDays(date: Date, amount: number): Date;
}
```

그리고 구체적인 구현체를 이 인터페이스에 맞게 조정한다.

이때 `Adapter` 패턴을 활용할 수 있다.

/date-time/MomentAdapter.ts
```TypeScript
import moment from "moment";
import type DateTime from "./DateTime";

export default class MomentAdapter implements DateTime {
  addDays(date: Date, amount: number): Date {
    return moment(date).add(amount, "days").toDate();
  }
  isSameDay(dateLeft: Date, dateRight: Date): boolean {
    return moment(dateLeft).isSame(dateRight, "days");
  }
}
```

모듈 외부에선 굳이 이러한 구체적인 내용을 알 필요가 없다.
`index.js` 는 여러모로 실패한 디자인이라고 많이 이야기하지만 개인적으로는 이럴때 요긴하게 쓰고있다.

/date-time/index.ts
```TypeScript
import type DateTime from "./DateTime";
import Adapter from "./MomentAdapter";

const instance: DateTime = new Adapter();

export function isSameDay(dateLeft: Date, dateRight: Date): boolean {
  return instance.isSameDay(dateLeft, dateRight);
}
export function addDays(date: Date, amount: number): Date {
  return instance.addDays(date, amount);
}
```

모듈 외부에서 접근하는 엔트리포인트라고 할 수 있는 `index.ts` 에 구체적으로 어떤 구현체를 사용할지에 대한 책임을 부여한다.

사용하는쪽에서는 기존에 사용하던 다른 모듈들을 사용할때와 동일하게 사용한다.

```TypeScript
import { isSameDay } from "@/libs/date-time";

const isEditable = isSameDay(new Date(), article.createdDate);
```

기반 기술중 서버와 HTTP를 통해 메세지를 주고 받는 책임을 갖는 HTTP Client의 경우에 특별히 더 신경을 써줄 부분이 있다.

우선 동일하게 HTTP 요청/응답에 대한 인터페이스 `HTTPClient` 를 정의한다.

개발팀 내부에서 정의한 응답 포맷이 있을테고 기본적으로 이 포맷에 맞춰 응답을 벗겨낸 후 반환하게 될테지만, 간혹 외부 서비스의 API를 요청하는 경우도 종종 있으므로 사용하는쪽에서 이 전략을 선택할 수 있는 여지를 주면 좋다.

표현력을 높이기 위해 객체 생성을 위한 별도의 `Builder` 를 제공하는 방향으로 구현하였다.

서버와 약속된 프로토콜 (서버에서 요청시 포함시켜달라고 요청한 헤더나 응답코드/예외코드에 대한 처리 규칙등)을 캡슐화하여 외부에서는 이 내용에 대해서 신경쓰지 않아도 되도록 한다.

마찬가지로 해당 인터페이스와 사용하려는 구체적인 구현체의 인터페이스를 맞춰주는 `Adapter` 를 구현한다. 또한 이때 구체적인 구현체의 응답 인터페이스가 상위 계층으로 그대로 노출되지 않도록 한다.

--- 예제추가

## API Client

클라이언트 애플리케이션에서 서비스의 정책이나 업무 규칙을 처리하는 Domain과 API Client는 뗄래야 땔 수 없는 관계이다.

### 서버 API의 구체적인 구현 내용은 다른 계층에서 알게해선 안된다.

이제 이 `HTTPClient` 를 사용하여 실제로 서버 API 에 요청을 보내는 책임을 갖는 삐삐를 구현한다.

이때 유의할점은 서버의 응답을 그대로 다른 계층에 노출하지 않아야 한다는 것이다.

서버의 응답을 서버의 응답을 그대로 상위계층에 노출할 경우 다음과 같은 문제가 발생한다.

서버 응답 변경에 영향을 받음..

동일한 개념을 나타내는 두개의 API.. 레거시일 확률이 높은.. 이거 맞춰주다보면 이러한 로직이 비즈니스 로직과 섞여서 복잡합을 야기한다..

이 책임을 해당 계층으로 격리하고 외부에선 이를 모르게 해라.. 프론트엔드 애플리케이션에서 정의한 도메인 모델 객체를 생성하여 반환하게 하고 상위 계층에서 이를 반환할거라고 기대할 수 있게 해라..

## Domain
서비스의 정책이나 업무 규칙에 해당하는 비즈니스 로직을 해당 계층으로 격리한다. 대부분의 개념은 DDD 에서 채용하였으며 각 요소를 간단히 소개하면 다음과 같다..

중요한건 도메인 계층 그 자체가 아니라 이 책임을 UI 계층에서 분리해내는데 있다.

엔티티..

밸류오브젝트..

서비스..

레파지토리..

위에 인프라계층이랑 관계 다이어그램 한번 더

## Application

해당 계층엔 애플리케이션이 동작하도록 하는데 관심을 갖는 객체들로 구성된다.

당연히도 Vue Application 이기 때문에 해당 계층부턴 Vue 가 그 기반에 깔리게 된다.

기반 기술도 아니고, 서비스의 정책이나 업무 규칙을 나타내는 도메인 객체도 아니면서 API 요청과 응답에 대한 객체가 아닌데다 UI와 관련이 있지만 UI 그 자체는 아닌 어디에도 속하지 않는 대부분이 이 계층에 위치할것이다.

예를들면 페이지간의 네비게이션을 담당하는 `router`, 애플리케이션 전역에서 접근이 필요한 상태를 관리하는 `store`, 애플리케이션의 특정 로직과 상태를 캡슐화한 `compositions (hooks)` 등등이 있겠다.

이중 `store` 의 설계에 대해서 자세히 설명하고 넘어가도록 하자.

### Store
페이지 단위로 구성되면 안된다.. 정보의 파편화.. 애플리케이션 전역의 상태관리라는걸 잊지 말것..

서비스의 정책이나 업무 규칙을 직접 처리해서도 안된다.. 도메인 계층에 위임할것..

오로지 애플리케이션 전역에서 접근이 필요한 상태를 메모리에 적재하고 이 상태 객체들의 라이프 사이클을 관리하기 위한 도구로만 사용이 되어야 한다..

예를들어주면 좋겠다..

## UI

뷰 애플리케이션의 UI 를 설계하는 방법에 대해서 소개한다..

container presentation

provide/inject

page Store

page context
